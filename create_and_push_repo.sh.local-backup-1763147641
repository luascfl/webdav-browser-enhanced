#!/usr/bin/env bash

set -euo pipefail

# Globals -------------------------------------------------------------------
declare -a __UNTRACKED_BACKUPS=()
trap '__restore_all_backups' EXIT INT TERM

main() {
  ensure_dependencies
  ensure_token

  local repo_dir repo_name script_rel action current_branch remote_url
  repo_dir=$(pwd)
  repo_name=$(basename "$repo_dir")
  script_rel=$(script_relative_path "$repo_dir")
  action=$(prompt_push_or_pull "$repo_name")

  init_git_repo
  current_branch=$(ensure_main_branch)
  remote_url=$(resolve_remote_url "$repo_name")

  if [[ "$action" == "push" ]]; then
    ensure_remote_repo_exists "$repo_name"
  fi

  ensure_remote "$remote_url"
  sync_with_remote "$current_branch"

  if [[ "$action" == "push" ]]; then
    perform_push "$script_rel" "$current_branch" "$remote_url"
  else
    echo "Pull concluído com sucesso de: $remote_url"
  fi
}

# Dependency / token helpers -------------------------------------------------
ensure_dependencies() {
  local dep
  for dep in git curl python3; do
    if ! command -v "$dep" >/dev/null 2>&1; then
      echo "Erro: dependência '$dep' não encontrada no PATH." >&2
      exit 1
    fi
  done
}

ensure_token() {
  if [[ -n "${GITHUB_TOKEN:-}" ]]; then
    return
  fi

  local token_file
  for token_file in GITHUB_TOKEN GITHUB_TOKEN.txt; do
    if [[ -f "$token_file" ]]; then
      if load_token_from_file "$token_file"; then
        export GITHUB_TOKEN
        return
      fi
    fi
  done

  echo "Erro: informe GITHUB_TOKEN via variável de ambiente ou arquivo." >&2
  exit 1
}

load_token_from_file() {
  local token_file=$1 token
  token=$(python3 - "$token_file" <<'PY'
import sys
from pathlib import Path
path = Path(sys.argv[1])
try:
    text = path.read_text(encoding="utf-8")
except Exception:
    sys.exit(1)
line = text.splitlines()[0] if text else ""
print(line.lstrip("\ufeff"), end="")
PY
) || return 1

  if [[ -n "$token" ]]; then
    GITHUB_TOKEN=$token
    return 0
  fi
  return 1
}

# Repo setup -----------------------------------------------------------------
script_relative_path() {
  local repo_dir=$1
  if command -v realpath >/dev/null 2>&1; then
    realpath --relative-to="$repo_dir" "$0" 2>/dev/null || basename "$0"
    return
  fi

  python3 - "$repo_dir" "$0" <<'PY'
import os, sys
repo, script = map(os.path.abspath, sys.argv[1:])
try:
    print(os.path.relpath(script, repo))
except ValueError:
    print(os.path.basename(script))
PY
}

prompt_push_or_pull() {
  local repo_name=$1 choice
  while true; do
    if ! read -rp "Deseja fazer push ou pull para o repositório '$repo_name'? [push/pull] (padrão: push): " choice; then
      choice=""
    fi
    case "${choice,,}" in
      ""|push) echo "push"; return ;;
      pull) echo "pull"; return ;;
      *) echo "Entrada inválida. Digite 'push' ou 'pull'." >&2 ;;
    esac
  done
}

init_git_repo() {
  if [[ ! -d .git ]]; then
    git init >/dev/null 2>&1
  fi
}

ensure_main_branch() {
  local current
  current=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || true)
  if [[ -z "$current" || "$current" == "HEAD" ]]; then
    git symbolic-ref HEAD refs/heads/main >/dev/null 2>&1 || git branch -M main
    current="main"
  elif [[ "$current" != "main" ]]; then
    git branch -M "$current" main
    current="main"
  fi
  echo "$current"
}

resolve_remote_url() {
  local repo_name=$1
  case "${GITHUB_REMOTE_PROTOCOL:-https}" in
    ssh) echo "git@github.com:luascfl/$repo_name.git" ;;
    https|*) echo "https://github.com/luascfl/$repo_name.git" ;;
  esac
}

ensure_remote_repo_exists() {
  local repo_name=$1
  local response http_status
  response=$(mktemp)
  http_status=$(curl -sS -w "%{http_code}" -o "$response" \
    -X POST "https://api.github.com/user/repos" \
    -H "Authorization: token $GITHUB_TOKEN" \
    -H "Accept: application/vnd.github+json" \
    -d "{\"name\":\"$repo_name\",\"private\":false}")

  case "$http_status" in
    201) ;;
    422) echo "Aviso: o repositório '$repo_name' já existe em luascfl. Prosseguindo." >&2 ;;
    *) echo "Erro ao criar repositório (status $http_status):" >&2
       cat "$response" >&2
       rm -f "$response"
       exit 1 ;;
  esac
  rm -f "$response"
}

ensure_remote() {
  local expected=$1
  if git remote get-url origin >/dev/null 2>&1; then
    local current
    current=$(git remote get-url origin)
    if [[ "$current" != "$expected" ]]; then
      echo "Erro: remoto 'origin' aponta para $current (esperado $expected)." >&2
      exit 1
    fi
  else
    git remote add origin "$expected"
  fi
}

# Sync -----------------------------------------------------------------------
sync_with_remote() {
  local branch=$1
  if git ls-remote --exit-code --heads origin "$branch" >/dev/null 2>&1; then
    echo "Branch remoto '$branch' encontrado. Sincronizando (pull --rebase)..." >&2
    if pull_with_credentials "$branch"; then
      echo "Sincronização concluída." >&2
    else
      echo "Aviso: pull não pôde ser concluído automaticamente." >&2
    fi
  else
    echo "Branch remoto '$branch' não encontrado. Presumindo primeiro push/pull." >&2
  fi
}

# Push -----------------------------------------------------------------------
perform_push() {
  local script_rel=$1 branch=$2 remote_url=$3
  stage_files_excluding_script "$script_rel"
  if commit_changes; then
    echo "Commit criado." >&2
  else
    echo "Nenhuma alteração para commitar." >&2
  fi

  if push_with_credentials "$branch"; then
    echo "Push concluído com sucesso: $remote_url"
  else
    echo "Falha ao fazer push." >&2
    exit 1
  fi
}

stage_files_excluding_script() {
  local script_rel=$1
  ensure_token_gitignore
  git add --all
  protect_path "$script_rel"
  protect_path "GITHUB_TOKEN"
  protect_path "GITHUB_TOKEN.txt"
  protect_path "AMO_API_KEY.txt"
  protect_path "AMO_API_SECRET.txt"
}

ensure_token_gitignore() {
  local gitignore=.gitignore
  local entries=("GITHUB_TOKEN" "GITHUB_TOKEN.txt" "AMO_API_KEY.txt" "AMO_API_SECRET.txt" "*API*")
  if [[ ! -f $gitignore ]]; then
    printf "%s\n" "${entries[@]}" > "$gitignore"
    return
  fi

  local entry
  for entry in "${entries[@]}"; do
    if ! grep -Fxq "$entry" "$gitignore"; then
      printf "%s\n" "$entry" >> "$gitignore"
    fi
  done
}

protect_path() {
  local path=$1
  [[ -z "$path" ]] && return
  git restore --staged -- "$path" >/dev/null 2>&1 || git reset HEAD -- "$path" >/dev/null 2>&1 || true
  if git ls-files --error-unmatch "$path" >/dev/null 2>&1; then
    return
  fi
  git rm --cached -- "$path" >/dev/null 2>&1 || true
}

commit_changes() {
  if git diff --staged --quiet; then
    return 1
  fi
  git commit -m "push"
  return 0
}

# Credentials helpers --------------------------------------------------------
run_with_https_credentials() {
  local askpass status
  askpass=$(mktemp)
  cat >"$askpass" <<'ASKPASS'
#!/usr/bin/env bash
if [[ "$1" == *Username* ]]; then
  printf '%s\n' "luascfl"
else
  printf '%s\n' "${GITHUB_TOKEN}"
fi
ASKPASS
  chmod +x "$askpass"
  GIT_TERMINAL_PROMPT=0 GIT_ASKPASS="$askpass" "$@"
  status=$?
  rm -f "$askpass"
  return $status
}

push_with_credentials() {
  local branch=$1 output status
  if [[ "${GITHUB_REMOTE_PROTOCOL:-https}" == "https" ]]; then
    output=$(run_with_https_credentials git push -u origin "$branch" 2>&1)
  else
    output=$(git push -u origin "$branch" 2>&1)
  fi
  status=$?
  printf "%s\n" "$output"
  if [[ $status -ne 0 && "$output" =~ non-fast-forward ]]; then
    echo "Push rejeitado (non-fast-forward). Tentando pull automático antes de repetir..." >&2
    if pull_with_credentials "$branch" && push_with_credentials "$branch"; then
      return 0
    fi
  fi
  return $status
}

# Pull / rebase --------------------------------------------------------------
pull_with_credentials() {
  local branch=$1 output
  if output=$(run_git_pull_command "$branch"); then
    printf "%s\n" "$output"
    __restore_all_backups
    return 0
  fi

  if is_untracked_overwrite_error "$output"; then
    if resolve_untracked_overwrite_conflicts "$branch" "$output"; then
      __restore_all_backups
      return 0
    fi
  fi

  if rebase_in_progress && auto_resolve_rebase_conflicts "$branch"; then
    __restore_all_backups
    return 0
  fi

  __restore_all_backups
  printf "%s\n" "$output" >&2
  echo "Aviso: 'pull --rebase' falhou. Pode haver conflitos que exigem intervenção manual." >&2
  return 1
}

run_git_pull_command() {
  local branch=$1 output status
  if [[ "${GITHUB_REMOTE_PROTOCOL:-https}" == "https" ]]; then
    output=$(run_with_https_credentials git pull --rebase --autostash origin "$branch" 2>&1)
  else
    output=$(git pull --rebase --autostash origin "$branch" 2>&1)
  fi
  status=$?
  printf "%s" "$output"
  return $status
}

is_untracked_overwrite_error() {
  grep -q "untracked working tree files would be overwritten" <<<"$1"
}

resolve_untracked_overwrite_conflicts() {
  local branch=$1 message=$2 path backup timestamp
  timestamp=$(date +%s)

  while read -r path; do
    [[ -z "$path" ]] && continue
    [[ ! -e "$path" ]] && continue

    backup="${path}.local-backup-${timestamp}"
    while [[ -e "$backup" ]]; do
      backup="${backup}-${RANDOM}"
    done

    cp -a -- "$path" "$backup"
    rm -rf -- "$path"
    __register_backup "$path" "$backup"
    echo "Arquivo local '$path' foi salvo temporariamente em '$backup' para permitir o pull." >&2
  done < <(extract_untracked_conflict_paths "$message")

  local retry
  if retry=$(run_git_pull_command "$branch"); then
    printf "%s\n" "$retry"
    return 0
  fi

  printf "%s\n" "$retry" >&2
  return 1
}

extract_untracked_conflict_paths() {
  awk '
    /untracked working tree files would be overwritten by checkout:/ {collect=1; next}
    /Please move or remove them before you switch branches/ {collect=0}
    collect && NF { gsub(/^[[:space:]]+/, "", $0); print }
  ' <<<"$1"
}

__register_backup() {
  __UNTRACKED_BACKUPS+=("$1|$2")
}

__restore_all_backups() {
  local entry original backup
  if [[ ${#__UNTRACKED_BACKUPS[@]} -eq 0 ]]; then
    return
  fi

  for entry in "${__UNTRACKED_BACKUPS[@]}"; do
    original=${entry%%|*}
    backup=${entry#*|}
    [[ -z "$original" || -z "$backup" ]] && continue
    if [[ -e "$backup" ]]; then
      rm -rf -- "$original"
      mv -- "$backup" "$original"
      echo "Versão local restaurada: $original" >&2
    fi
  done
  __UNTRACKED_BACKUPS=()
}

rebase_in_progress() {
  [[ -d .git/rebase-apply || -d .git/rebase-merge ]]
}

auto_resolve_rebase_conflicts() {
  local branch=$1
  local -a conflicts
  mapfile -t conflicts < <(git diff --name-only --diff-filter=U)

  if [[ ${#conflicts[@]} -eq 0 ]]; then
    abort_rebase_with_warning "Rebase em andamento, mas nenhum arquivo em conflito foi detectado automaticamente."
    return 1
  fi

  local file
  for file in "${conflicts[@]}"; do
    if ! resolve_conflict_for_file "$file"; then
      abort_rebase_with_warning "Conflito em '$file' requer resolução manual."
      return 1
    fi
  done

  if git rebase --continue >/tmp/rebase-continue.log 2>&1; then
    cat /tmp/rebase-continue.log
    rm -f /tmp/rebase-continue.log
    return 0
  fi

  abort_rebase_with_warning "Não foi possível concluir o rebase automaticamente."
  return 1
}

resolve_conflict_for_file() {
  local file=$1
  case "$file" in
    .gitignore)
      git checkout --theirs -- .gitignore >/dev/null 2>&1 || return 1
      ensure_token_gitignore
      git add .gitignore
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

abort_rebase_with_warning() {
  local message=$1
  local status_output
  status_output=$(git status --short 2>/dev/null || true)
  git rebase --abort >/dev/null 2>&1 || true
  echo "$message" >&2
  if [[ -n "$status_output" ]]; then
    echo "Arquivos em conflito:" >&2
    echo "$status_output" >&2
  fi
}

main "$@"
